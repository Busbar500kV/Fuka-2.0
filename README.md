Fuka 2.0 — Architectural Narrative

1. Conceptual Model

Fuka 2.0 is a simulation system where a substrate evolves in interaction with an external environment. Both evolve over discrete timesteps, and energy transfer is always causal (no instantaneous long-range effects).
	•	The environment is a timeline of energy fields generated by moving Gaussian sources. It can be one-dimensional (time × space) or two-dimensional (time × height × space).
	•	The substrate is a grid of the same dimensionality as the environment (after resampling). It receives energy from the environment and redistributes energy among its cells.
	•	The physics rules define how substrate values evolve at each tick:
	•	Neighbor-to-neighbor conservative exchange (bounded by local conductivity).
	•	Environment coupling (bounded per tick).
	•	Global decay.
	•	Thermal bath noise.
	•	Motor noise.
	•	Telemetry is collected every tick, tracking substrate and environment energies as well as statistical measures such as entropy and variance.

The goal is not to solve a classical physics system, but to create a controlled environment where causality, entropy increase, and emergent patterns can be observed.

⸻

2. Module Overview

Application Layer (app.py)
	•	Provides a Streamlit-based graphical user interface.
	•	Reads a single configuration file (defaults.json) that specifies all parameters.
	•	Automatically generates sliders, checkboxes, and text fields for every parameter — no parameters are hardcoded in the UI.
	•	Runs the engine with the given configuration and visualizes results in real time.
	•	Supports optional live streaming updates, 2-D combined heatmaps, 1-D energy timeseries, and sparse 3-D scatter plots.

Configuration Layer (core/config.py)
	•	Defines two structured objects:
	•	Config: top-level simulation settings.
	•	FieldCfg: environment-specific settings.
	•	Converts defaults.json into these objects using a factory method.
	•	Normalizes values (e.g., ensures valid boundary condition strings).
	•	Collects both “classic” physics parameters (flux, motor, diffusion, decay) and any additional physics knobs (alpha speed, beta speed, flux limits, noise levels, update mode).
	•	Designed to be future-proof: if new knobs appear in JSON, they automatically propagate to the physics step.

Environment Layer (core/env.py)
	•	Builds the environment timeline given a configuration and random generator.
	•	Two modes:
	•	1-D: produces arrays shaped (time, space).
	•	2-D: produces arrays shaped (time, height, space).
	•	Environment activity is generated from sources:
	•	moving_peak: a Gaussian bump that travels across the space.
	•	moving_peak_2d: a 2-D Gaussian traveling across both axes.
	•	Can add Gaussian noise to every frame.
	•	All fields are periodic: sources that travel past one edge wrap around seamlessly.

Physics Layer (core/physics.py)
	•	Implements the update rule for the substrate each tick.
	•	Works for both 1-D and 2-D substrates.
	•	Core features:
	•	Local conductivity: each cell has a speed factor that grows with normalized local energy.
	•	Conservative neighbor exchange: energy lost by one cell is gained by its neighbor.
	•	Environment coupling: substrate is pulled toward environment values, but this pull is capped per tick (ensuring causality).
	•	Decay: global fractional reduction of energy each tick.
	•	Thermal noise: zero-mean Gaussian fluctuations.
	•	Motor noise: exploratory perturbations scaled by local energy (encourages activity around edges).
	•	Boundary handling: depending on boundary condition, edges can reflect, wrap, absorb, or leak.
	•	Returns both the updated substrate and a flux metric (mean magnitude of applied environment coupling).

Engine Layer (core/engine.py)
	•	Coordinates the simulation.
	•	Responsibilities:
	•	Build environment from configuration.
	•	Allocate substrate arrays of the correct dimension.
	•	Loop over timesteps and call the physics function.
	•	Resample environment to substrate resolution when needed.
	•	Collect telemetry after each tick.
	•	Maintains dimensional consistency (1-D vs 2-D).
	•	Compatible with both live updates (streaming callbacks) and full-run batch execution.

Telemetry Layer (core/organism.py)
	•	Defines the History object used to collect metrics.
	•	Stores:
	•	Time steps.
	•	Mean substrate energy.
	•	Mean environment energy.
	•	Mean flux.
	•	Optional deeper metrics such as entropy, variance, and total mass.
	•	Accessible to the UI for plotting time series.

⸻

3. Configuration File (defaults.json)

The configuration file drives the entire system.

Required sections
	•	Random seed.
	•	Global frames (time steps).
	•	Substrate space dimension.
	•	Physics knobs (flux, motor, diffuse, decay, band, boundary condition).
	•	Environment configuration (length, height, frames, noise, sources).

Optional sections
	•	Streaming controls: whether to update the UI live and at what chunk interval.
	•	Visualization controls: heatmap thresholds, gamma, opacities.
	•	3-D visualization controls: threshold and maximum points.
	•	Extended physics knobs: alpha speed, beta speed, flux limits, thermal noise, update mode, boundary leak.

The app refuses to run if required keys are missing.

⸻

4. Visualization Modes
	•	Combined Heatmap: overlays environment and substrate in 2-D. For 2-D environments, only the first y-slice is shown.
	•	Energy Timeseries: shows how average energies and flux evolve over time.
	•	Sparse 3-D Scatter Plot: shows substrate and environment activity above a threshold, rendered in three axes (x, y, t). For 1-D environments, y is a pseudo-layer axis distinguishing environment from substrate.

⸻

5. Key Design Principles
	1.	Strict configuration: The entire project runs off a single JSON file. No defaults are buried in code.
	2.	Causality: Local speed caps prevent simultaneity violations. No signal propagates faster than allowed by local energy.
	3.	Entropy emerges: Noise and bounded exchanges naturally increase entropy, without enforcing a global second law.
	4.	Extensibility: Any new parameter added to JSON automatically flows into the physics engine and appears in the UI.
	5.	Transparency: Telemetry exposes core metrics at every time step for interpretability.

⸻
